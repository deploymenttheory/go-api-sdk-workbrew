package mocks

import (
	"net/http"

	"github.com/jarcoal/httpmock"
)

// VulnerabilityChangesMock handles mock HTTP responses for vulnerability changes
type VulnerabilityChangesMock struct{}

// RegisterMocks registers all success mock responses
func (m *VulnerabilityChangesMock) RegisterMocks(baseURL string) {
	// Mock GET /vulnerability_changes.json
	httpmock.RegisterResponder("GET", baseURL+"/vulnerability_changes.json",
		func(req *http.Request) (*http.Response, error) {
			mockResponse := `[
  {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "event_type": "vulnerability.detected",
    "occurred_at": "2024-10-01T09:15:00Z",
    "status": "detected",
    "device_id": "device-uuid-123",
    "device_serial_number": "TC6R2DHVHG",
    "formula_name": "curl",
    "formula_version": "8.7.0",
    "vulnerability_id": "CVE-2024-2466",
    "cvss_severity": "Medium",
    "cvss_score": 6.5
  },
  {
    "id": "123e4567-e89b-12d3-a456-426614174001",
    "event_type": "vulnerability.fixed",
    "occurred_at": "2024-10-02T10:30:00Z",
    "status": "fixed",
    "device_id": "device-uuid-456",
    "device_serial_number": "1234567890",
    "formula_name": "wget",
    "formula_version": "1.24.5",
    "vulnerability_id": "CVE-2024-10524",
    "cvss_severity": "High",
    "cvss_score": 8.1
  }
]`
			return httpmock.NewStringResponse(200, mockResponse), nil
		},
	)

	// Mock GET /vulnerability_changes.csv
	httpmock.RegisterResponder("GET", baseURL+"/vulnerability_changes.csv",
		func(req *http.Request) (*http.Response, error) {
			mockResponse := `id,event_type,occurred_at,status,device_id,device_serial_number,formula_name,formula_version,vulnerability_id,cvss_severity,cvss_score
123e4567-e89b-12d3-a456-426614174000,vulnerability.detected,2024-10-01T09:15:00Z,detected,device-uuid-123,TC6R2DHVHG,curl,8.7.0,CVE-2024-2466,Medium,6.5
123e4567-e89b-12d3-a456-426614174001,vulnerability.fixed,2024-10-02T10:30:00Z,fixed,device-uuid-456,1234567890,wget,1.24.5,CVE-2024-10524,High,8.1`
			return httpmock.NewStringResponse(200, mockResponse), nil
		},
	)
}

// RegisterErrorMocks registers error response mocks
func (m *VulnerabilityChangesMock) RegisterErrorMocks(baseURL string) {
	// Mock unauthorized error
	httpmock.RegisterResponder("GET", baseURL+"/vulnerability_changes.json",
		func(req *http.Request) (*http.Response, error) {
			errorResponse := `{
  "message": "Unauthorized",
  "errors": ["Invalid API key"]
}`
			return httpmock.NewStringResponse(401, errorResponse), nil
		},
	)

	httpmock.RegisterResponder("GET", baseURL+"/vulnerability_changes.csv",
		func(req *http.Request) (*http.Response, error) {
			errorResponse := `{
  "message": "Unauthorized",
  "errors": ["Invalid API key"]
}`
			return httpmock.NewStringResponse(401, errorResponse), nil
		},
	)
}

// CleanupMockState cleans up any state from the mock
func (m *VulnerabilityChangesMock) CleanupMockState() {
	// No cleanup needed for stateless mocks
}
