package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"

	"github.com/deploymenttheory/go-api-sdk-workbrew/workbrew"
	"github.com/deploymenttheory/go-api-sdk-workbrew/workbrew/client"
	"github.com/deploymenttheory/go-api-sdk-workbrew/workbrew/services/vulnerabilitychanges"
)

func main() {
	fmt.Println("=== Workbrew - Vulnerability Changes Example ===")

	// API credentials
	apiKey := "your-api-key-here"
	workspaceName := "your-workspace"

	// Create client
	wbClient, err := workbrew.NewClient(
		apiKey,
		workspaceName,
		client.WithDebug(),
	)
	if err != nil {
		log.Fatalf("Failed to create client: %v", err)
	}

	ctx := context.Background()

	// Example 1: Get all vulnerability changes (no filter)
	fmt.Println("\n=== Example 1: Get All Vulnerability Changes ===")

	allChanges, err := wbClient.VulnerabilityChanges.GetVulnerabilityChanges(ctx, nil)
	if err != nil {
		log.Fatalf("Failed to get vulnerability changes: %v", err)
	}

	fmt.Printf("Found %d vulnerability changes:\n\n", len(*allChanges))

	// Show first 5 changes
	for i, change := range *allChanges {
		if i >= 5 {
			break
		}
		fmt.Printf("Change %d:\n", i+1)
		fmt.Printf("  ID: %s\n", change.ID)
		fmt.Printf("  Event Type: %s\n", change.EventType)
		fmt.Printf("  Status: %s\n", change.Status)
		fmt.Printf("  Formula: %s @ %s\n", change.FormulaName, change.FormulaVersion)
		fmt.Printf("  Vulnerability: %s\n", change.VulnerabilityID)

		if change.CVSSSeverity != nil {
			fmt.Printf("  CVSS Severity: %s\n", *change.CVSSSeverity)
		}
		if change.CVSSScore != nil {
			fmt.Printf("  CVSS Score: %.1f\n", *change.CVSSScore)
		}
		if change.DeviceSerialNumber != nil {
			fmt.Printf("  Device: %s\n", *change.DeviceSerialNumber)
		}

		fmt.Printf("  Occurred At: %s\n", change.OccurredAt.Format("2006-01-02 15:04:05"))
		fmt.Println()
	}

	// Example 2: Filter by detected vulnerabilities
	fmt.Println("\n=== Example 2: Get Detected Vulnerabilities ===")

	detectedVulns, err := wbClient.VulnerabilityChanges.GetVulnerabilityChanges(ctx,
		&vulnerabilitychanges.RequestQueryOptions{
			Status: "detected",
		})
	if err != nil {
		log.Fatalf("Failed to get detected vulnerabilities: %v", err)
	}

	fmt.Printf("Found %d detected vulnerabilities\n", len(*detectedVulns))

	// Example 3: Filter by fixed vulnerabilities
	fmt.Println("\n=== Example 3: Get Fixed Vulnerabilities ===")

	fixedVulns, err := wbClient.VulnerabilityChanges.GetVulnerabilityChanges(ctx,
		&vulnerabilitychanges.RequestQueryOptions{
			Status: "fixed",
		})
	if err != nil {
		log.Fatalf("Failed to get fixed vulnerabilities: %v", err)
	}

	fmt.Printf("Found %d fixed vulnerabilities\n", len(*fixedVulns))

	// Example 4: Search for specific formula
	fmt.Println("\n=== Example 4: Search for 'curl' Vulnerabilities ===")

	curlVulns, err := wbClient.VulnerabilityChanges.GetVulnerabilityChanges(ctx,
		&vulnerabilitychanges.RequestQueryOptions{
			Query: "curl",
		})
	if err != nil {
		log.Fatalf("Failed to search vulnerabilities: %v", err)
	}

	fmt.Printf("Found %d vulnerability changes related to 'curl':\n\n", len(*curlVulns))

	for i, vuln := range *curlVulns {
		if i >= 3 {
			break
		}
		fmt.Printf("%d. %s - %s (Status: %s)\n",
			i+1,
			vuln.FormulaName,
			vuln.VulnerabilityID,
			vuln.Status)
	}

	// Example 5: Combine filters - detected vulnerabilities for specific query
	fmt.Println("\n=== Example 5: Detected Vulnerabilities for 'curl' ===")

	detectedCurl, err := wbClient.VulnerabilityChanges.GetVulnerabilityChanges(ctx,
		&vulnerabilitychanges.RequestQueryOptions{
			Status: "detected",
			Query:  "curl",
		})
	if err != nil {
		log.Fatalf("Failed to get filtered vulnerabilities: %v", err)
	}

	fmt.Printf("Found %d detected 'curl' vulnerabilities\n", len(*detectedCurl))

	// Example 6: Get vulnerability changes in CSV format
	fmt.Println("\n=== Example 6: Get Vulnerability Changes (CSV) ===")

	csvData, err := wbClient.VulnerabilityChanges.GetVulnerabilityChangesCSV(ctx,
		&vulnerabilitychanges.RequestQueryOptions{
			Status: "detected",
		})
	if err != nil {
		log.Fatalf("Failed to get vulnerability changes CSV: %v", err)
	}

	fmt.Printf("Retrieved CSV data (%d bytes):\n", len(csvData))
	fmt.Println(string(csvData[:min(500, len(csvData))]) + "...")

	// Example 7: Get CSV with download flag
	fmt.Println("\n=== Example 7: Get CSV with Download Flag ===")

	downloadCSV, err := wbClient.VulnerabilityChanges.GetVulnerabilityChangesCSV(ctx,
		&vulnerabilitychanges.RequestQueryOptions{
			Status:   "detected",
			Download: true, // Forces download=1 query parameter
		})
	if err != nil {
		log.Fatalf("Failed to get CSV with download: %v", err)
	}

	fmt.Printf("Retrieved downloadable CSV data (%d bytes)\n", len(downloadCSV))

	// Example 8: Analyze vulnerability severity distribution
	fmt.Println("\n=== Example 8: Vulnerability Severity Analysis ===")

	severityCount := make(map[string]int)
	for _, change := range *allChanges {
		if change.CVSSSeverity != nil {
			severityCount[*change.CVSSSeverity]++
		} else {
			severityCount["Unknown"]++
		}
	}

	fmt.Println("Severity Distribution:")
	for severity, count := range severityCount {
		fmt.Printf("  %s: %d\n", severity, count)
	}

	// Example 9: Find high-severity vulnerabilities
	fmt.Println("\n=== Example 9: High-Severity Vulnerabilities (CVSS >= 7.0) ===")

	highSeverity := 0
	for _, change := range *allChanges {
		if change.CVSSScore != nil && *change.CVSSScore >= 7.0 {
			highSeverity++
			if highSeverity <= 5 { // Show first 5
				fmt.Printf("  %s: %s (CVSS: %.1f)\n",
					change.FormulaName,
					change.VulnerabilityID,
					*change.CVSSScore)
			}
		}
	}

	fmt.Printf("\nTotal high-severity vulnerabilities: %d\n", highSeverity)

	// Example 10: Pretty print JSON response
	fmt.Println("\n=== Example 10: Full JSON Response (First 2 Changes) ===")

	if len(*allChanges) > 2 {
		sample := (*allChanges)[:2]
		jsonData, err := json.MarshalIndent(sample, "", "  ")
		if err != nil {
			log.Printf("Error marshaling response to JSON: %v", err)
		} else {
			fmt.Println(string(jsonData))
		}
	}

	fmt.Println("\n=== Example Complete ===")
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
